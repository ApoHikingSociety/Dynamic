-- Roblox Modular UI Library - DynamicUI
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

local DynamicUI = {}
DynamicUI.__index = DynamicUI

-- Default Config
DynamicUI.Config = {
    ToggleAnimation = "Bounce",
    ToggleDuration = 0.25,
    Theme = "Rainbow", -- "Default" or "Rainbow"
    RainbowSpeed = 0.3,

    DropShadow = {
        Transparency = 1,
        Size = UDim2.new(1,0,0,10),
        Position = UDim2.new(0,0,1,0),
    },

    TextLift = {
        OffsetX = 1.2,
        OffsetY = 1,
        Transparency = 0.5,
        Color = Color3.new(0,0,0),
    }
}

---------------------------------------------------------------------
-- UTILITIES
---------------------------------------------------------------------

function DynamicUI:CreateDropShadow(parent, options)
    local opt = {}
    for k,v in pairs(self.Config.DropShadow) do opt[k] = v end
    if options then for k,v in pairs(options) do opt[k] = v end end

    local shadow = Instance.new("ImageLabel")
    shadow.Name = "DropShadow"
    shadow.BackgroundTransparency = opt.Transparency
    shadow.BorderSizePixel = 0
    shadow.Image = self.Images and self.Images["DropShadow"] or ""
    shadow.Size = opt.Size
    shadow.Position = opt.Position
    shadow.ZIndex = -1
    shadow.Parent = parent
    return shadow
end

function DynamicUI:CreateTextLift(textLabel, options)
    local opt = {}
    for k, v in pairs(self.Config.TextLift) do opt[k] = v end
    if options then for k, v in pairs(options) do opt[k] = v end end

    local oldShadow = textLabel.Parent:FindFirstChild(textLabel.Name .. "_Shadow")
    if oldShadow then oldShadow:Destroy() end

    local shadow = textLabel:Clone()
    shadow.Name = textLabel.Name .. "_Shadow"
    shadow.TextColor3 = opt.Color
    shadow.TextTransparency = opt.Transparency
    shadow.Position = textLabel.Position + UDim2.new(0, opt.OffsetX, 0, opt.OffsetY)
    shadow.ZIndex = textLabel.ZIndex - 1
    shadow.Parent = textLabel.Parent

    textLabel:GetPropertyChangedSignal("Position"):Connect(function()
        shadow.Position = textLabel.Position + UDim2.new(0, opt.OffsetX, 0, opt.OffsetY)
    end)
    textLabel:GetPropertyChangedSignal("Size"):Connect(function()
        shadow.Size = textLabel.Size
    end)
    textLabel:GetPropertyChangedSignal("AnchorPoint"):Connect(function()
        shadow.AnchorPoint = textLabel.AnchorPoint
    end)
    textLabel:GetPropertyChangedSignal("Text"):Connect(function()
        shadow.Text = textLabel.Text
    end)
    textLabel:GetPropertyChangedSignal("Font"):Connect(function()
        shadow.Font = textLabel.Font
    end)
    textLabel:GetPropertyChangedSignal("TextSize"):Connect(function()
        shadow.TextSize = textLabel.TextSize
    end)
    textLabel:GetPropertyChangedSignal("TextScaled"):Connect(function()
        shadow.TextScaled = textLabel.TextScaled
    end)

    return shadow
end

--------------------------------------------------------------------
-- CreateGlowImage
-- Generates a behind-text glow ImageLabel with configurable options.
--------------------------------------------------------------------
function DynamicUI:CreateGlowImage(parent, options)
    -- default configuration
    local opt = {
        Name            = "Glow",
        ImageKey        = "Glow",             -- key in self.Images
        Size            = UDim2.new(0.7, 0, 1, 40),
        Position        = UDim2.new(-0.1, 0, -0.6, 0),
        ImageTransparency= 0.8,
        ImageColor3     = Color3.fromRGB(255, 255, 255),
        ZOffset         = -1,                 -- relative to parent ZIndex
        BackgroundTransparency = 1,
        BorderSizePixel = 0
    }

    -- merge any user-supplied overrides
    if options then
        for k, v in pairs(options) do
            opt[k] = v
        end
    end

    -- create the image
    local glow = Instance.new("ImageLabel")
    glow.Name                   = opt.Name
    glow.BackgroundTransparency = opt.BackgroundTransparency
    glow.BorderSizePixel        = opt.BorderSizePixel
    glow.Image                  = self.Images and self.Images["Glow"] or ""
    glow.Size                   = opt.Size
    glow.Position               = opt.Position
    glow.ImageTransparency      = opt.ImageTransparency
    glow.ImageColor3            = opt.ImageColor3
    -- place behind the parentâ€™s text/object
    glow.ZIndex                 = (parent and parent.ZIndex or 1) + opt.ZOffset

    glow.Parent = parent
    return glow
end

---------------------------------------------------------------------
-- CONSTRUCTOR
---------------------------------------------------------------------

function DynamicUI.new(config)
	local self = setmetatable({}, DynamicUI)
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local Lighting = game:GetService("Lighting")
	local HttpService = game:GetService("HttpService")
	local LocalPlayer = Players.LocalPlayer
	local PlayerGui = (LocalPlayer and LocalPlayer:FindFirstChild("PlayerGui")) or PlayerGui
	self.Config = self.Config or {}
	if config then
		for k, v in pairs(config) do
			self.Config[k] = v
		end
	end
	self.Config.Theme = self.Config.Theme or "Rainbow"
	self.Config.RainbowSpeed = self.Config.RainbowSpeed or 1
	self.Config.ToggleAnimation = self.Config.ToggleAnimation or "Default"
	self.Config.CustomColors = self.Config.CustomColors or {
		Color3.fromRGB(255, 0, 0),
		Color3.fromRGB(255, 127, 0),
		Color3.fromRGB(255, 255, 0),
		Color3.fromRGB(0, 255, 0),
		Color3.fromRGB(0, 0, 255),
		Color3.fromRGB(75, 0, 130),
		Color3.fromRGB(148, 0, 211)
	}
	self.Config.CustomColorCount = math.clamp(self.Config.CustomColorCount or 3, 1, 7)
	local customColors = {}
	for i = 1, 7 do
		customColors[i] = self.Config.CustomColors[i] or self.Config.CustomColors[((i - 1) % # self.Config.CustomColors) + 1]
	end
	local function safeIsFile(p)
		local ok, res = pcall(function() return isfile(p) end)
		return ok and res
	end
	local function safeWriteFile(p, d)
		pcall(function() writefile(p, d) end)
	end
	local function safeReadFile(p)
		local ok, res = pcall(function() return readfile(p) end)
		return ok and res or nil
	end
	local function safeListFiles(p)
		local ok, res = pcall(function() return listfiles(p) end)
		return ok and (res or {})
	end
	local function safeGetCustomAsset(p)
		local ok, res = pcall(function() return getcustomasset(p) end)
		return ok and res or nil
	end
	local function ensureFolder(path)
		if not isfolder(path) then
			makefolder(path)
		end
	end
	ensureFolder("Dynamic")
	ensureFolder("Dynamic/Assets")
	ensureFolder("Dynamic/Assets/Images")
	ensureFolder("Dynamic/Assets/Sounds")
	ensureFolder("Dynamic/Assets/Skyboxes")
	ensureFolder("Dynamic/Config")
	self.Images = {}
	local httpRequest = (syn and syn.request) or http_request or request
	local function fetchImage(name, url)
		local path = ("Dynamic/Assets/Images/%s.%s"):format(name, url:match("%.(%w+)$") or "png")
		if not safeIsFile(path) and httpRequest and type(url) == "string" and url:match("^https?://") then
			local ok, res = pcall(function()
				return httpRequest({Url = url, Method = "GET"})
			end)
			if ok and res and res.Body then
				safeWriteFile(path, res.Body)
			end
		end
		if safeIsFile(path) then
			local asset = safeGetCustomAsset(path)
			if asset then
				self.Images[name] = asset
			end
		end
	end
	local imageList = {
		ToggledImage = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Images/ToggledImage.png",
		CircleImage = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Images/CircleImage.png",
		TabHolderImage = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Images/TabHolderImage.png",
		TabBackgroundImage = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Images/TabBackgroundImage.png",
		ArrowUp = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Images/ArrowUp.png",
		ArrowDown = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Images/ArrowDown.png",
		ColorWheel = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Images/ColorWheel.png",
		DropShadow = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Images/DropShadow.png",
		Veil = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Images/Veil.png",
		Glow = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Images/Glow.png"
	}
	for n, u in pairs(imageList) do
		fetchImage(n, u)
	end
	for _, file in ipairs(safeListFiles("Dynamic/Assets/Images")) do
		if file:match("%.png$") or file:match("%.jpe?g$") then
			local n = file:match("([^/\\]+)%.%w+$")
			if n and not self.Images[n] then
				local asset = safeGetCustomAsset(file)
				if asset then
					self.Images[n] = asset
				end
			end
		end
	end
	local function autoImportImagesFromFolder(folderPath)
		local files = safeListFiles(folderPath)
		for _, file in ipairs(files) do
			if file:match("%.png$") or file:match("%.jpe?g$") or file:match("%.webp$") then
				local name = file:match("([^/\\]+)%.%w+$")
				if name and not self.Images[name] then
					local asset = safeGetCustomAsset(file)
					if asset then
						self.Images[name] = asset
					else
						if httpRequest and file:match("^https?://") then
							fetchImage(name, file)
						end
					end
				end
			end
		end
	end
	autoImportImagesFromFolder("Dynamic/Assets/Images")
	autoImportImagesFromFolder("/Assests/Icons")
	for _, file in ipairs(safeListFiles("/Assests/Icons")) do
		if file:match("%.png$") or file:match("%.jpe?g$") then
			local n = file:match("([^/\\]+)%.%w+$")
			if n and not self.Images[n] then
				local asset = safeGetCustomAsset(file)
				if asset then
					self.Images[n] = asset
				end
			end
		end
	end
	function self:GetImage(n)
		if not n then return nil end
		if self.Images[n] then return self.Images[n] end
		local tries = {
			("Dynamic/Assets/Images/%s.png"):format(n),
			("Dynamic/Assets/Images/%s.jpg"):format(n),
			("/Assests/Icons/%s.png"):format(n),
			("/Assests/Icons/%s.jpg"):format(n)
		}
		for _, p in ipairs(tries) do
			local asset = safeGetCustomAsset(p)
			if asset then
				self.Images[n] = asset
				return asset
			end
		end
		return nil
	end
	self.Sounds = {}
	local function fetchSound(name, url)
		local path = ("Dynamic/Assets/Sounds/%s.%s"):format(name, url:match("%.(%w+)$") or "mp3")
		if not safeIsFile(path) and httpRequest and type(url) == "string" and url:match("^https?://") then
			local ok, res = pcall(function() return httpRequest({Url = url, Method = "GET"}) end)
			if ok and res and res.Body then
				safeWriteFile(path, res.Body)
			end
		end
		if safeIsFile(path) then
			local asset = safeGetCustomAsset(path)
			if asset then
				self.Sounds[name] = asset
			end
		end
	end
	local soundList = {
		CelestialOn = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Sounds/celestial_on.wav",
		CelestialOff = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Sounds/celestial_off.wav",
		SmoothOn = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Sounds/smooth_on.wav",
		SmoothOff = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Sounds/smooth_off.wav",
		NursultanOn = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Sounds/nursultan_on.wav",
		NursultanOff = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Sounds/nursultan_off.wav"
	}
	for n, u in pairs(soundList) do
		fetchSound(n, u)
	end
	for _, file in ipairs(safeListFiles("Dynamic/Assets/Sounds")) do
		if file:match("%.mp3$") or file:match("%.wav$") then
			local n = file:match("([^/\\]+)%.%w+$")
			if n and not self.Sounds[n] then
				local asset = safeGetCustomAsset(file)
				if asset then
					self.Sounds[n] = asset
				end
			end
		end
	end
	function self:GetSound(n)
		return self.Sounds[n]
	end
	self.ScreenGui = Instance.new("ScreenGui")
	self.ScreenGui.Name = "DynamicUI"
	self.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	self.ScreenGui.ResetOnSpawn = false
	self.ScreenGui.Parent = PlayerGui
	self.Tabs, self.Visible = {}, false
	self.Flags = self.Flags or {}
	self._flagControls = self._flagControls or {}
	local WatermarkGui = Instance.new("ScreenGui")
	WatermarkGui.Name = "DynamicWatermarkGui"
	WatermarkGui.IgnoreGuiInset = true
	WatermarkGui.ResetOnSpawn = false
	WatermarkGui.DisplayOrder = 999999
	WatermarkGui.Parent = game:GetService("CoreGui")
	local watermark = Instance.new("TextLabel")
	watermark.Name = "Watermark"
	watermark.Text = "Dynamic"
	watermark.FontFace = Font.new("rbxassetid://12187365559", Enum.FontWeight.Bold)
	watermark.TextSize = 70
	watermark.TextColor3 = Color3.fromRGB(255, 255, 255)
	watermark.BackgroundTransparency = 1
	watermark.Size = UDim2.new(0, 300, 0, 70)
	watermark.Position = UDim2.new(0, 30, 0, 10)
	watermark.TextXAlignment = Enum.TextXAlignment.Left
	watermark.ZIndex = 999999
	watermark.Parent = WatermarkGui
	local glowImage = self:CreateGlowImage(watermark, {ImageTransparency = 0.8, ImageColor3 = Color3.fromRGB(255, 255, 255)})
	local rainbowOffset, customOffset = 0, 0
	local function clamp(x, a, b) return math.max(a, math.min(b, x)) end
	local function nColorBlend(t)
		local count = clamp(math.floor((self.Config.CustomColorCount or 1) + 0.5), 1, 7)
		if count <= 1 then return customColors[1] end
		local seg = (t % 1) * count
		local idx = math.floor(seg) + 1
		local frac = seg - math.floor(seg)
		local a, b = customColors[idx], customColors[(idx % count) + 1]
		return a:lerp(b, frac)
	end
	local function applySequence(seq)
		if not watermark:FindFirstChild("UIGradient") then
			local g = Instance.new("UIGradient")
			g.Rotation = 0
			g.Parent = watermark
		end
		watermark.UIGradient.Color = seq
		if not glowImage:FindFirstChild("UIGradient") then
			local g = Instance.new("UIGradient")
			g.Rotation = 0
			g.Parent = glowImage
		end
		glowImage.UIGradient.Color = seq
		if self.BackgroundVeil then
			if not self.BackgroundVeil:FindFirstChild("UIGradient") then
				local g = Instance.new("UIGradient")
				g.Rotation = 0
				g.Parent = self.BackgroundVeil
			end
			self.BackgroundVeil.UIGradient.Color = seq
		end
		for _, tab in ipairs(self.Tabs) do
			for _, module in ipairs(tab.Modules) do
				if module._Toggled and module._Gradient then
					module._Gradient.Enabled = true
					module._Gradient.Color = seq
					module.Button.BackgroundColor3 = Color3.new(1, 1, 1)
				else
					if module._Gradient then module._Gradient.Enabled = false end
					module.Button.BackgroundColor3 = Color3.fromRGB(28, 28, 28)
				end
				for _, element in ipairs(module.Elements) do
					if element.Toggled or element.IsSlider or element.IsDropdown then
						if element.Gradient then element.Gradient.Color = seq end
						if element.ModifiedGradient then element.ModifiedGradient.Color = seq end
						if element.Gradients then for _, g in pairs(element.Gradients) do g.Color = seq end end
					end
				end
			end
		end
		for _, item in pairs(self.ArraylistItems or {}) do
			if item.Gradient then item.Gradient.Color = seq end
		end
	end
	local function updateGradients(dt)
		local speed = self.Config.RainbowSpeed or 1
		if self.Config.Theme == "Rainbow" then
			rainbowOffset = (rainbowOffset + dt * speed) % 1
			local c1 = Color3.fromHSV(rainbowOffset, 1, 1)
			local c2 = Color3.fromHSV((rainbowOffset + 0.1) % 1, 1, 1)
			applySequence(ColorSequence.new{ColorSequenceKeypoint.new(0, c1), ColorSequenceKeypoint.new(1, c2)})
		elseif self.Config.Theme == "Custom" then
			customOffset = (customOffset + dt * speed) % 1
			local c1 = nColorBlend(customOffset)
			local c2 = nColorBlend(customOffset + 0.1)
			applySequence(ColorSequence.new{ColorSequenceKeypoint.new(0, c1), ColorSequenceKeypoint.new(1, c2)})
		else
			for _, tab in ipairs(self.Tabs) do
				for _, module in ipairs(tab.Modules) do
					if module._Gradient then module._Gradient.Enabled = false end
					module.Button.BackgroundColor3 = module._Toggled and Color3.fromRGB(50, 50, 50) or Color3.fromRGB(28, 28, 28)
					for _, element in ipairs(module.Elements) do
						if element.ModifiedGradient then element.ModifiedGradient.Enabled = false end
						if element.Gradient then element.Gradient.Enabled = false end
						if element.Gradients then for _, g in pairs(element.Gradients) do g.Enabled = false end end
					end
				end
			end
		end
	end
	RunService.RenderStepped:Connect(updateGradients)
	updateGradients(0)
	self.SettingsTab = self:AddTab("Settings")
	self.SettingsTab.Holder.LayoutOrder = 999999
	self.ClickGUIModule = self:AddModule(self.SettingsTab, "Click Gui", Enum.KeyCode.Insert, true, function(toggled)
		self:ToggleUI(toggled)
		if self.BackgroundFog then self.BackgroundFog.Enabled = toggled end
		if self.BackgroundVeil then self.BackgroundVeil.Visible = toggled end
		self.Flags.ClickGUI = toggled
	end)
	self._flagControls["ClickGUI"] = self.ClickGUIModule
	self.Visible = self.ClickGUIModule._Toggled
	self.Flags.ClickGUI = self.ClickGUIModule._Toggled
	local fog = Lighting:FindFirstChild("BackgroundFog") or Instance.new("BlurEffect")
	fog.Name = "BackgroundFog"
	fog.Size = 24
	fog.Enabled = self.ClickGUIModule._Toggled
	fog.Parent = Lighting
	self.BackgroundFog = fog
	local veil = Instance.new("ImageLabel")
	veil.Name = "BackgroundVeil"
	veil.BackgroundTransparency = 1
	veil.Size = UDim2.new(1, 0, 1, 0)
	veil.ScaleType = Enum.ScaleType.Stretch
	veil.ZIndex = 0
	veil.Image = self.Images["Veil"] or ""
	veil.Visible = self.ClickGUIModule._Toggled
	veil.Parent = self.ScreenGui
	self.BackgroundVeil = veil
	local animChoices = {"Default","Fade","Bounce","Slide"}
	self:AddDropdown(self.ClickGUIModule, "Animation", animChoices, table.find(animChoices, self.Config.ClickGUIAnimation) or 1, function(choice) self.Config.ClickGUIAnimation = choice end)
	self:AddSlider(self.ClickGUIModule, "Blur Strength", 0, 100, fog.Size, function(val) fog.Size = val end, nil, 1)
	local interfaceModule = self:AddModule(self.SettingsTab, "Interface", nil, true, function() end, "Interface", true, false)
	self:AddDropdown(interfaceModule, "Theme", {"Rainbow","Custom"}, (self.Config.Theme == "Rainbow") and 1 or 2, function(choice)
		self.Config.Theme = choice
		if self.colorCountSlider and self.colorCountSlider.RefreshVisibility then self.colorCountSlider.RefreshVisibility() end
		for _, cp in ipairs(self.colorPickers or {}) do if cp.RefreshVisibility then cp.RefreshVisibility() end end
	end)
	local hue = 0
	RunService.RenderStepped:Connect(function(dt)
		hue = (hue + dt * (self.Config.RainbowSpeed or 0.1)) % 1
		local seq
		if self.Config.Theme == "Rainbow" then
			local c = Color3.fromHSV(hue, 1, 1)
			seq = ColorSequence.new(c, c)
		elseif self.Config.Theme == "Custom" then
			local c = nColorBlend(hue)
			seq = ColorSequence.new(c, c)
		else
			local c = Color3.new(1, 1, 1)
			seq = ColorSequence.new(c, c)
		end
		applySequence(seq)
	end)
	local function customVisible(index)
		if self.Config.Theme ~= "Custom" then return false end
		if not index then return true end
		return (self.Config.CustomColorCount or 1) >= index
	end
	self.colorPickers = {}
	self.colorCountSlider = self:AddSlider(interfaceModule, "Colors", 1, 7, self.Config.CustomColorCount, function(val)
		local n = math.clamp(math.floor(val + 0.5), 1, 7)
		self.Config.CustomColorCount = n
		for _, cp in ipairs(self.colorPickers) do if cp.RefreshVisibility then cp.RefreshVisibility() end end
	end, function() return customVisible() end, 0)
	self.colorCountSlider.RefreshVisibility = function()
		local visible = customVisible()
		if self.colorCountSlider.SetVisible then
			self.colorCountSlider:SetVisible(visible)
		else
			self.colorCountSlider.Visible = visible
		end
	end
	for i = 1, 7 do
		local cp = self:AddColorKey(interfaceModule, ("Color %d"):format(i), customColors[i], function(c)
			customColors[i] = c
			self.Config.CustomColors[i] = c
		end, function() return customVisible(i) end)
		cp.RefreshVisibility = function()
			local visible = customVisible(i)
			if cp.SetVisible then cp:SetVisible(visible) elseif cp.Visible ~= nil then cp.Visible = visible end
		end
		self.colorPickers[i] = cp
		self._flagControls["Color" .. i] = cp
		self.Flags["Color" .. i] = customColors[i]
	end
	if self.colorCountSlider.RefreshVisibility then self.colorCountSlider.RefreshVisibility() end
	for _, cp in ipairs(self.colorPickers) do if cp.RefreshVisibility then cp.RefreshVisibility() end end
	self:AddSlider(interfaceModule, "Color Speed", 0.1, 5, self.Config.RainbowSpeed, function(val) self.Config.RainbowSpeed = val end, nil, 2)
	self.Skyboxes = { sky512 = { SkyboxBk = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Skyboxes/sky512_bk.png", SkyboxFt = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Skyboxes/sky512_ft.png", SkyboxLf = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Skyboxes/sky512_lf.png", SkyboxRt = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Skyboxes/sky512_rt.png", SkyboxUp = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Skyboxes/sky512_up.png", SkyboxDn = "https://raw.githubusercontent.com/ApoHikingSociety/Dynamic/main/Library/Assets/Skyboxes/sky512_dn.png", } }
	local skyFaces = { Up = "SkyboxUp", Dn = "SkyboxDn", Ft = "SkyboxFt", Bk = "SkyboxBk", Lf = "SkyboxLf", Rt = "SkyboxRt" }
	for name, faces in pairs(self.Skyboxes) do
		if type(faces) == "table" then
			for faceName, url in pairs(faces) do
				if type(url) == "string" and httpRequest then
					local ext = url:match("%.(%w+)$") or "png"
					local filename = ("Dynamic/Assets/Skyboxes/%s_%s.%s"):format(name, faceName, ext)
					if not safeIsFile(filename) then
						pcall(function()
							local res = httpRequest({ Url = url, Method = "GET" })
							if res and res.Body then safeWriteFile(filename, res.Body) end
						end)
					end
				end
			end
		end
	end
	for _, file in ipairs(safeListFiles("Dynamic/Assets/Skyboxes")) do
		if file:match("%.png$") or file:match("%.jpe?g$") then
			local base, face = file:match("([^/\\]+)_(Skybox%a+)%.[^%.]+$")
			if not base then base, face = file:match("([^/\\]+)([A-Z][a-z][A-Za-z]*)%.[^%.]+$") end
			if base and face and skyFaces[face:gsub("Skybox", "") or face] then
				local nameOnly = base
				self.Skyboxes[nameOnly] = self.Skyboxes[nameOnly] or {}
				local asset = safeGetCustomAsset(file)
				if asset then
					local faceKey = face
					if not faceKey:match("^Skybox") then faceKey = skyFaces[face] or faceKey end
					self.Skyboxes[nameOnly][faceKey] = asset
				end
			end
		end
	end
	local function clearSkies()
		for _, obj in ipairs(Lighting:GetChildren()) do if obj:IsA("Sky") then obj:Destroy() end end
	end
	local function createDefaultSky()
		clearSkies()
		local defaultSky = Instance.new("Sky")
		defaultSky.Name = "DefaultSky"
		defaultSky.SkyboxBk = "rbxasset://textures/sky/sky512_bk.tex"
		defaultSky.SkyboxDn = "rbxasset://textures/sky/sky512_dn.tex"
		defaultSky.SkyboxFt = "rbxasset://textures/sky/sky512_ft.tex"
		defaultSky.SkyboxLf = "rbxasset://textures/sky/sky512_lf.tex"
		defaultSky.SkyboxRt = "rbxasset://textures/sky/sky512_rt.tex"
		defaultSky.SkyboxUp = "rbxasset://textures/sky/sky512_up.tex"
		defaultSky.Parent = Lighting
	end
	local function applySky(name)
		if not name then return end
		local faces = self.Skyboxes[name]
		if not faces or type(faces) ~= "table" then return end
		clearSkies()
		local sky = Instance.new("Sky")
		sky.Name = name
		for faceKey, asset in pairs(faces) do pcall(function() sky[faceKey] = asset end) end
		sky.Parent = Lighting
	end
	local skyboxModule = self:AddModule(self.SettingsTab, "Skybox", nil, true, function(enabled)
		if not enabled then createDefaultSky() else if currentSelection then applySky(currentSelection) else local t = {} for n, f in pairs(self.Skyboxes) do if type(f) == "table" then table.insert(t, n) end end table.sort(t) if t[1] then currentSelection = t[1]; applySky(t[1]) end end end)
	local currentSelection = nil
	local skyNames = {}
	for name, faces in pairs(self.Skyboxes) do if type(faces) == "table" then table.insert(skyNames, name) end end
	table.sort(skyNames)
	self:AddDropdown(skyboxModule, "Select Skybox", skyNames, 1, function(selectedName) currentSelection = selectedName if skyboxModule._Toggled then applySky(selectedName) end self.Flags.SelectedSkybox = selectedName end)
	self._flagControls["SelectedSkybox"] = skyboxModule
	self.Flags.SelectedSkybox = skyNames[1]
	local defaultName = skyNames[1]
	if defaultName then currentSelection = defaultName if skyboxModule._Toggled then applySky(defaultName) else createDefaultSky() end end
	function self:SaveConfig(filename)
		if not filename or filename == "" then return false end
		local ok, encoded = pcall(function() return HttpService:JSONEncode(self.Flags or {}) end)
		if not ok or not encoded then return false end
		local path = ("Dynamic/Config/%s.json"):format(filename)
		pcall(function() writefile(path, encoded) end)
		return true
	end
	function self:LoadConfig(filename)
		if not filename or filename == "" then return false end
		local path = ("Dynamic/Config/%s.json"):format(filename)
		local raw = safeReadFile(path)
		if not raw then return false end
		local ok, data = pcall(function() return HttpService:JSONDecode(raw) end)
		if not ok or type(data) ~= "table" then return false end
		for k, v in pairs(data) do
			self.Flags[k] = v
			local control = self._flagControls and self._flagControls[k]
			if control then
				if type(control) == "table" then
					if control.SetValue and type(control.SetValue) == "function" then pcall(function() control:SetValue(v) end)
					elseif control.Set and type(control.Set) == "function" then pcall(function() control:Set(v) end)
					elseif control.SetToggleState and type(control.SetToggleState) == "function" then pcall(function() control:SetToggleState(v) end)
					elseif control._Toggled ~= nil then pcall(function() control._Toggled = v DynamicUI:UpdateModuleVisualState(control) if control.Callback then pcall(control.Callback, control._Toggled) end end)
					else pcall(function() control.Value = v end)
				end
				else pcall(function() control.Value = v end)
				end
			end
		end
		return true
	end
	local configFolder = "Dynamic/Config"
	ensureFolder(configFolder)
	local currentConfigName = "default"
	local pendingName = ""
	local function listConfigNames()
		local names = {}
		for _, f in ipairs(listfiles(configFolder)) do
			local n = f:match("([^/\\]+)%.json$")
			if n then table.insert(names, n) end
		end
		table.sort(names)
		if not table.find(names, "default") then table.insert(names, 1, "default") end
		return names
	end
	local function loadInitialConfig()
		local p = string.format("%s/%s.json", configFolder, currentConfigName)
		local raw = safeReadFile(p)
		if not raw then return {} end
		local ok, data = pcall(function() return HttpService:JSONDecode(raw) end)
		return ok and type(data) == "table" and data or {}
	end
	self.Flags = loadInitialConfig()
	self._flagControls = {}
	local function autoSave()
		local ok, encoded = pcall(function() return HttpService:JSONEncode(self.Flags) end)
		if ok then pcall(function() writefile(string.format("%s/%s.json", configFolder, currentConfigName), encoded) end) end
	end
	local function SetFromLoad(control, value)
		if type(control) == "table" then
			if control.SetValue then control:SetValue(value, true)
			elseif control.Set then control:Set(value, true)
			elseif control.SetToggleState then control:SetToggleState(value, true)
			elseif control.Value ~= nil then control.Value = value end
		end
	end
	function self:RegisterFlag(name, defaultValue, controlRef)
		if not name then return end
		if self.Flags[name] == nil then self.Flags[name] = defaultValue end
		if controlRef then self._flagControls[name] = controlRef SetFromLoad(controlRef, self.Flags[name]) end
		if controlRef then
			if controlRef.SetValue then
				local old = controlRef.SetValue
				function controlRef:SetValue(v, silent)
					old(self, v)
					if not silent then self.Flags[name] = v; autoSave() end
				end
			elseif controlRef.Set then
				local old = controlRef.Set
				function controlRef:Set(v, silent)
					old(self, v)
					if not silent then self.Flags[name] = v; autoSave() end
				end
			elseif controlRef.SetToggleState then
				local old = controlRef.SetToggleState
				function controlRef:SetToggleState(v, silent)
					old(self, v, silent)
					if not silent then self.Flags[name] = v; autoSave() end
				end
			end
		end
	end
	setmetatable(self.Flags, { __newindex = function(t, k, v) rawset(t, k, v) autoSave() end })
	local configDropdown
	local function refreshConfigDropdown()
		if configDropdown and configDropdown.Refresh then configDropdown:Refresh(listConfigNames(), currentConfigName) end
	end
	local configModule = self:AddModule(self.SettingsTab, "Config", nil, true, function()
		local name = (pendingName ~= "" and pendingName) or currentConfigName
		currentConfigName = name
		autoSave()
		refreshConfigDropdown()
	end, "Config", true, false)
	self:AddInputBox(configModule, "New Config Name", "", function(txt, enterPressed)
		pendingName = txt and txt:gsub("[%c%p%s]+", "_") or ""
		if enterPressed and pendingName ~= "" then
			local path = string.format("%s/%s.json", configFolder, pendingName)
			if not isfile(path) then writefile(path, "{}") end
			currentConfigName = pendingName
			autoSave()
			refreshConfigDropdown()
		end
	end)
	configDropdown = self:AddDropdown(configModule, "Select Config", listConfigNames(), currentConfigName, function(selected)
		if not selected or selected == "" then return end
		currentConfigName = selected
		local path = string.format("%s/%s.json", configFolder, currentConfigName)
		local raw = safeReadFile(path)
		if not raw then return end
		local ok, data = pcall(function() return HttpService:JSONDecode(raw) end)
		if ok and type(data) == "table" then for k, v in pairs(data) do self.Flags[k] = v local c = self._flagControls[k] if c then SetFromLoad(c, v) end end end
	end)
	self:AddArraylist()
	return self
end


function DynamicUI:AddArraylist()
    local task = task
    local UI = self
    if UI.ScreenGui then
        UI.ScreenGui.DisplayOrder = 9999
        UI.ScreenGui.IgnoreGuiInset = true
    end
    local frame = Instance.new("Frame")
    frame.Name = "ArraylistFrame"
    frame.BackgroundTransparency = 1
    frame.Size = UDim2.new(0, 200, 1, 0)
    frame.Position = UDim2.new(1, -205, 0, 10)
    frame.ZIndex = 10000
    frame.Visible = false
    frame.Parent = UI.ScreenGui
    UI.ArraylistFrame = frame
    UI.ArraylistItems = UI.ArraylistItems or {}
    UI.ArraylistSortMode = UI.ArraylistSortMode or "Length"
    UI._arrayBtnCounter = UI._arrayBtnCounter or 0

    local function playTween(obj, props)
        local ok, t = pcall(function()
            return TweenService:Create(obj, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), props)
        end)
        if ok and t then
            local finished = false
            local conn
            conn = t.Completed:Connect(function()
                finished = true
                conn:Disconnect()
            end)
            t:Play()
            return t, function()
                if not finished then
                    pcall(function() t:Cancel() end)
                end
            end
        end
        return nil, nil
    end

    local function animateItem(item, appearing)
        if not item then return end
        if item._animating and item._appearing == appearing then return end
        item._animating = true
        item._appearing = appearing
        local btn, shadow, bp, sp = item.Button, item.Shadow, item.BtnPad, item.ShadowPad
        local tweens = {}
        local cancels = {}
        if bp then
            local goal = appearing and 0 or -200
            local t, cancel = playTween(bp, { PaddingRight = UDim.new(0, goal) })
            if t then table.insert(tweens, t) table.insert(cancels, cancel) end
        end
        if sp then
            local goal = appearing and 0 or -200
            local t, cancel = playTween(sp, { PaddingRight = UDim.new(0, goal) })
            if t then table.insert(tweens, t) table.insert(cancels, cancel) end
        end
        if btn then
            local t, cancel = playTween(btn, { TextTransparency = appearing and 0 or 1 })
            if t then table.insert(tweens, t) table.insert(cancels, cancel) end
        end
        if shadow then
            local t, cancel = playTween(shadow, { TextTransparency = appearing and 0 or 1 })
            if t then table.insert(tweens, t) table.insert(cancels, cancel) end
        end
        if #tweens == 0 then
            item._animating = false
            item._appearing = nil
            if not appearing and item._pendingRemove then
                if item.Shadow and item.Shadow.Parent then item.Shadow:Destroy() end
                if item.Button and item.Button.Parent then item.Button:Destroy() end
                for k,v in pairs(UI.ArraylistItems) do
                    if v == item then UI.ArraylistItems[k] = nil end
                end
            end
            return
        end
        local remaining = #tweens
        for _, t in ipairs(tweens) do
            local conn
            conn = t.Completed:Connect(function()
                conn:Disconnect()
                remaining = remaining - 1
                if remaining <= 0 then
                    item._animating = false
                    item._appearing = nil
                    if not appearing and item._pendingRemove then
                        if item.Shadow and item.Shadow.Parent then item.Shadow:Destroy() end
                        if item.Button and item.Button.Parent then item.Button:Destroy() end
                        for k,v in pairs(UI.ArraylistItems) do
                            if v == item then UI.ArraylistItems[k] = nil end
                        end
                    end
                end
            end)
        end
    end

    local function layout(order)
        local y = 0
        for _, mod in ipairs(order) do
            local it = UI.ArraylistItems[mod]
            if it and it.Button and it.Button.Parent then
                it.Button.Position = UDim2.new(0, 0, 0, y)
                if it.Shadow and it.Shadow.Parent then
                    it.Shadow.Position = it.Button.Position + UDim2.new(0, 1.5, 0, 1.5)
                end
                y = y + 22
            end
        end
    end

    local function makeItemForModule(mod)
        UI._arrayBtnCounter = UI._arrayBtnCounter + 1
        local btn = Instance.new("TextButton")
        btn.Name = ("ArrayBtn_%d"):format(UI._arrayBtnCounter)
        btn.BackgroundTransparency = 1
        btn.Size = UDim2.new(1, 0, 0, 20)
        btn.Text = mod.Name or "Module"
        btn.FontFace = Font.new("rbxassetid://12187365559", Enum.FontWeight.Bold)
        btn.TextSize = 35
        btn.TextColor3 = Color3.new(1, 1, 1)
        btn.TextXAlignment = Enum.TextXAlignment.Right
        btn.ZIndex = frame.ZIndex + 1
        btn.TextTransparency = 1
        btn.Parent = frame
        btn.Visible = true
        local glow = UI:CreateGlowImage(btn, { ImageTransparency = 0.8, ImageColor3 = Color3.fromRGB(12, 12, 12), Position = UDim2.new(0.5, 0, -3, 0), Size = UDim2.new(1, -50, 1, 100), ImageTransparency = 0.9 })
        local shadow = UI:CreateTextLift(btn, { OffsetX = 1.5, OffsetY = 1.5, Color = Color3.new(0, 0, 0), Transparency = 0.25 })
        if shadow then
            shadow.TextTransparency = 1
            shadow.ZIndex = btn.ZIndex - 1
            shadow.Visible = true
        end
        local sp = Instance.new("UIPadding")
        sp.Name = "SlidePad"
        sp.PaddingRight = UDim.new(0, -200)
        sp.Parent = shadow
        local grad = Instance.new("UIGradient")
        grad.Color = ColorSequence.new{ ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)), ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 0)), ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 255)) }
        grad.Parent = btn
        local bp = Instance.new("UIPadding")
        bp.Name = "SlidePad"
        bp.PaddingRight = UDim.new(0, -200)
        bp.Parent = btn
        local item = { Button = btn, Shadow = shadow, Gradient = grad, BtnPad = bp, ShadowPad = sp, _animating = false, _appearing = nil, _pendingRemove = false }
        btn.MouseButton1Click:Connect(function()
            if mod._arraylistClickDebounce then return end
            mod._arraylistClickDebounce = true
            task.delay(0.12, function() mod._arraylistClickDebounce = false end)
            if type(mod.SetToggleState) == "function" then
                pcall(function() mod:SetToggleState(not mod._Toggled) end)
            else
                mod._Toggled = not mod._Toggled
            end
        end)
        return item
    end

    function UI:_LayoutArraylist(order)
        layout(order)
    end

    function UI:RefreshArraylist()
        local active = {}
        for _, tab in ipairs(UI.Tabs or {}) do
            for _, m in ipairs(tab.Modules or {}) do
                if m._Toggled and m.Name ~= "Arraylist" then
                    local visFlag = m.Name .. "_Visible"
                    local isVisible = true
                    if self.Flags and self.Flags[visFlag] ~= nil then
                        isVisible = self.Flags[visFlag]
                    end
                    if isVisible then
                        table.insert(active, m)
                    end
                end
            end
        end
        if UI.ArraylistSortMode == "Length" then
            table.sort(active, function(a, b)
                return #(a.Name:gsub("%s+", "")) > #(b.Name:gsub("%s+", ""))
            end)
        else
            table.sort(active, function(a, b)
                return (a.Name or ""):lower() < (b.Name or ""):lower()
            end)
        end
        local activeSet = {}
        for _, m in ipairs(active) do activeSet[m] = true end
        for mod, item in pairs(UI.ArraylistItems) do
            if not activeSet[mod] then
                if item._pendingRemove == false then
                    item._pendingRemove = true
                    animateItem(item, false)
                end
            end
        end
        for _, m in ipairs(active) do
            local existing = UI.ArraylistItems[m]
            if existing then
                existing._pendingRemove = false
                if existing.Button and existing.Button.Parent then
                    existing.Button.Text = m.Name or existing.Button.Text
                end
                if existing._appearing == false then
                    animateItem(existing, true)
                end
            else
                local it = makeItemForModule(m)
                UI.ArraylistItems[m] = it
                animateItem(it, true)
            end
        end
        layout(active)
    end

    local function hookModuleToggle(mod)
        if type(mod) ~= "table" then return end
        if mod._arraylistHooked then return end
        mod._arraylistHooked = true
        if type(mod.SetToggleState) == "function" then
            local orig = mod.SetToggleState
            mod.SetToggleState = function(selfMod, val, ...)
                local ok, res = pcall(orig, selfMod, val, ...)
                pcall(function() UI:RefreshArraylist() end)
                return ok and res
            end
        end
    end

    if not UI._arraylist_AddModuleWrapped then
        UI._arraylist_AddModuleWrapped = true
        local origAddModule = UI.AddModule
        UI.AddModule = function(uiSelf, tab, name, defaultValue, callback, ...)
            local newMod = origAddModule(uiSelf, tab, name, defaultValue, callback, ...)
            pcall(hookModuleToggle, newMod)
            return newMod
        end
    end

    for _, tab in ipairs(UI.Tabs or {}) do
        for _, mod in ipairs(tab.Modules or {}) do
            pcall(hookModuleToggle, mod)
        end
    end

    UI._arraylist_lastStates = UI._arraylist_lastStates or {}
    task.spawn(function()
        while true do
            task.wait(0.15)
            local changed = false
            for _, tab in ipairs(UI.Tabs or {}) do
                for _, mod in ipairs(tab.Modules or {}) do
                    local prev = UI._arraylist_lastStates[mod]
                    local now = not not mod._Toggled
                    if prev ~= now then
                        UI._arraylist_lastStates[mod] = now
                        changed = true
                    end
                end
            end
            if changed then
                pcall(function() UI:RefreshArraylist() end)
            end
            if not frame or not frame.Parent then
                break
            end
        end
    end)

    local arrayModule = UI:AddModule(UI.SettingsTab, "Arraylist", nil, true, function(on)
        frame.Visible = on
        if on then UI:RefreshArraylist() end
    end)

    local sortDropdown = UI:AddDropdown(arrayModule, "Layout Order", { "Length", "Alphabetical" }, "Length", function(choice)
        UI.ArraylistSortMode = choice
        if arrayModule._Toggled then UI:RefreshArraylist() end
    end)

    local saved = UI.Flags and UI.Flags["Layout Order"]
    if saved and table.find({ "Length", "Alphabetical" }, saved) then
        sortDropdown:SetValue(saved)
        UI.ArraylistSortMode = saved
    end

    local oldUpdate = UI.UpdateModuleVisualState
    UI.UpdateModuleVisualState = function(this, moduleObj)
        if oldUpdate then oldUpdate(this, moduleObj) end
        if arrayModule._Toggled then
            pcall(function() this:RefreshArraylist() end)
        end
    end

    if arrayModule._Toggled then
        frame.Visible = true
        UI:RefreshArraylist()
    end
end

function DynamicUI:ApplySequence(seq)
    for _, item in pairs(self.ArraylistItems or {}) do
        if item.Gradient then item.Gradient.Color = seq end
    end
    if self.OldApplySequence then self:OldApplySequence(seq) end
end


---------------------------------------------------------------------
-- TABS
---------------------------------------------------------------------

function DynamicUI:UpdateTabPositions()
    local tabWidth, tabSpacing = 200, 5
    local totalTabs = #self.Tabs
    local totalWidth = totalTabs * tabWidth + (totalTabs - 1) * tabSpacing
    local startX = (self.ScreenGui.AbsoluteSize.X - totalWidth) / 2

    -- Sort tabs by LayoutOrder before positioning
    table.sort(self.Tabs, function(a, b)
        return a.Holder.LayoutOrder < b.Holder.LayoutOrder
    end)

    for i, tab in ipairs(self.Tabs) do
        local posX = startX + ((i - 1) * (tabWidth + tabSpacing))
        tab.OriginalPosition = UDim2.new(0, posX, 0, 50)
        TweenService:Create(
            tab.Holder,
            TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            { Position = tab.OriginalPosition }
        ):Play()
        tab.SavedPosition = nil
    end
end

function DynamicUI:AddTab(tabName, tabIconId)
    local GuiService = game:GetService("GuiService")

    if self.ScreenGui then
        self.ScreenGui.DisplayOrder = 9999
        self.ScreenGui.IgnoreGuiInset = true
    end

    local tabHolder = Instance.new("ImageButton")
    tabHolder.Name = tabName .. "_Holder"
    tabHolder.Size = UDim2.new(0, 200, 0, 100)
    tabHolder.BackgroundTransparency = 1
    tabHolder.BorderSizePixel = 0
    tabHolder.Image = self.Images["TabHolderImage"]
    tabHolder.ZIndex = 1000
    tabHolder.Parent = self.ScreenGui

    local tabButton = Instance.new("TextButton")
    tabButton.Name = tabName
    tabButton.Size = UDim2.new(1, 0, 0, 35)
    tabButton.Position = UDim2.new(0, 0, 0, 0)
    tabButton.Text = tabName
    tabButton.TextSize = 28
    tabButton.FontFace = Font.new("rbxassetid://12187365559", Enum.FontWeight.Bold)
    tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    tabButton.BackgroundTransparency = 1
    tabButton.ZIndex = tabHolder.ZIndex + 1
    tabButton.Parent = tabHolder
    self:CreateTextLift(tabButton, {OffsetX = 1.2, OffsetY = 1, Color = Color3.fromRGB(145,145,145), Transparency = 0.5})

    local tabBackground = Instance.new("ImageLabel")
    tabBackground.Name = "TabBackground"
    tabBackground.Size = UDim2.new(1, 0, 0, 35)
    tabBackground.Position = tabButton.Position
    tabBackground.BackgroundTransparency = 1
    tabBackground.BorderSizePixel = 0
    tabBackground.Image = self.Images["TabBackgroundImage"]
    tabBackground.ZIndex = tabHolder.ZIndex
    tabBackground.Parent = tabHolder

    local tabsContainer = Instance.new("ScrollingFrame")
    tabsContainer.Name = "TabsContainer"
    tabsContainer.Active = true
    tabsContainer.Size = UDim2.new(1, 0, 1, -35)
    tabsContainer.Position = UDim2.new(0, 0, 0, 35)
    tabsContainer.BackgroundTransparency = 1
    tabsContainer.BorderSizePixel = 0
    tabsContainer.ScrollBarThickness = 0
    tabsContainer.AutomaticCanvasSize = Enum.AutomaticSize.None
    tabsContainer.ScrollingDirection = Enum.ScrollingDirection.Y
    tabsContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
    tabsContainer.ClipsDescendants = true
    tabsContainer.ZIndex = tabHolder.ZIndex + 1
    tabsContainer.Parent = tabHolder

    local tabLayout = Instance.new("UIListLayout")
    tabLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    tabLayout.SortOrder = Enum.SortOrder.LayoutOrder
    tabLayout.Padding = UDim.new(0, 0)
    tabLayout.Parent = tabsContainer

    local tabIcon = Instance.new("ImageButton")
    tabIcon.Name = "TabIcon"
    tabIcon.Size = UDim2.new(0, 16, 0, 16)
    tabIcon.Position = UDim2.new(0.056, 0, 0.28, 0)
    tabIcon.BackgroundTransparency = 1
    tabIcon.Image = tabIconId or "rbxassetid://10709781460"
    tabIcon.ZIndex = tabHolder.ZIndex + 2
    tabIcon.Parent = tabButton

    local tab = {
        Name = tabName,
        Holder = tabHolder,
        Container = tabsContainer,
        Button = tabButton,
        Modules = {},
        OriginalPosition = nil,
        SavedPosition = nil
    }

    local function updateSize()
        local layoutHeight = tabLayout.AbsoluteContentSize.Y
        local maxHeight = 400
        local newHeight = math.min(layoutHeight + 35, maxHeight)
        tabHolder.Size = UDim2.new(0, 200, 0, newHeight)
        tabsContainer.CanvasSize = UDim2.new(0, 0, 0, layoutHeight)
        tabsContainer.ScrollingEnabled = layoutHeight + 35 > maxHeight
    end

    tabLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateSize)
    updateSize()

    local dragging, dragInput, dragStart, startPos
    tabButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = tabHolder.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    tab.SavedPosition = tabHolder.Position
                end
            end)
        end
    end)

    tabButton.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            tabHolder.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    table.insert(self.Tabs, tab)
    table.sort(self.Tabs, function(a, b)
        return a.Holder.LayoutOrder < b.Holder.LayoutOrder
    end)
    self:UpdateTabPositions()

    local function updateMouse()
        local anyVisible = false
        for _, t in ipairs(self.Tabs) do
            if t.Holder.Visible then
                anyVisible = true
                break
            end
        end
        UserInputService.MouseIconEnabled = anyVisible
    end

    tabHolder:GetPropertyChangedSignal("Visible"):Connect(updateMouse)
    updateMouse()

    return tab
end

---------------------------------------------------------------------
-- MODULES
---------------------------------------------------------------------

function DynamicUI:AddModule(
    tab,
    moduleName,
    keybind,
    defaultValue,
    callback,
    flagName,
    alwaysOn,
    reenableOnPress
)
    local SoundService     = game:GetService("SoundService")

    self.Flags         = self.Flags or {}
    self._flagControls = self._flagControls or {}

    local actualFlag = flagName or moduleName
    if self.Flags[actualFlag] == nil then
        self.Flags[actualFlag] = defaultValue == true
    else
        defaultValue = self.Flags[actualFlag]
    end

    local moduleFrame = Instance.new("Frame")
    moduleFrame.Name = moduleName .. "_Frame"
    moduleFrame.Size = UDim2.new(1,0,0,30)
    moduleFrame.BackgroundTransparency = 1
    moduleFrame.Parent = tab.Container

    local moduleBtn = Instance.new("TextButton")
    moduleBtn.Name = moduleName
    moduleBtn.Size = UDim2.new(1,0,0,30)
    moduleBtn.BackgroundColor3 = Color3.fromRGB(28,28,28)
    moduleBtn.BorderSizePixel = 0
    moduleBtn.AutoButtonColor = false
    moduleBtn.Text = ""
    moduleBtn.ZIndex = 99
    moduleBtn.Parent = moduleFrame

    local moduleText = Instance.new("TextLabel")
    moduleText.Name = "ModuleText"
    moduleText.BackgroundTransparency = 1
    moduleText.Size = UDim2.new(1,0,1,0)
    moduleText.FontFace = Font.new("rbxassetid://12187365559")
    moduleText.TextSize = 24
    moduleText.TextColor3 = Color3.fromRGB(145,145,145)
    moduleText.Text = moduleName
    moduleText.Parent = moduleBtn
    self:CreateTextLift(moduleText)
    self:CreateDropShadow(moduleBtn)

    local gradient = Instance.new("UIGradient")
    gradient.Rotation = 0
    gradient.Name = "RainbowGradient"
    gradient.Transparency = NumberSequence.new(1)
    gradient.Parent = moduleBtn

    local moduleSettings = Instance.new("ScrollingFrame")
    moduleSettings.Name = "ModuleSettings"
    moduleSettings.Size = UDim2.new(1,0,0,0)
    moduleSettings.Position = UDim2.new(0,0,0,30)
    moduleSettings.BackgroundColor3 = Color3.fromRGB(26,26,26)
    moduleSettings.BorderSizePixel = 0
    moduleSettings.ClipsDescendants = true
    moduleSettings.ScrollBarThickness = 0
    moduleSettings.AutomaticCanvasSize = Enum.AutomaticSize.Y
    moduleSettings.CanvasSize = UDim2.new(0,0,0,0)
    moduleSettings.Parent = moduleFrame
    self:CreateDropShadow(moduleSettings)

    local layout = Instance.new("UIListLayout", moduleSettings)
    layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    layout.SortOrder = Enum.SortOrder.LayoutOrder

    local module = {
        Name        = moduleName,
        Frame       = moduleFrame,
        Button      = moduleBtn,
        Text        = moduleText,
        Settings    = moduleSettings,
        Elements    = {},
        _Toggled    = defaultValue or false,
        _Gradient   = gradient,
        _SettingsOpen = false,
        Keybind     = keybind or Enum.KeyCode.Unknown,
        Callback    = callback,
        ParentUI    = self,
        _Debounce   = false,
        FlagName    = actualFlag,
        AlwaysOn    = alwaysOn or false,
        ReenableOnPress = reenableOnPress or false,
    }

    function module:SetToggleState(state, suppressCallback)
        if type(state) ~= "boolean" then return end
        if self.AlwaysOn then state = true end
        self._Toggled = state
        self.ParentUI.Flags[self.FlagName] = state
        DynamicUI:UpdateModuleVisualState(self)
        if not suppressCallback and self.Callback then
            self.Callback(state)
        end
        if self.ParentUI.RefreshArraylist then
            self.ParentUI:RefreshArraylist()
        end
    end

    function module:Toggle(newState)
        if self._Debounce then return end
        self._Debounce = true
        local target
        if self.AlwaysOn then
            target = true
        elseif self.ReenableOnPress then
            target = true
        elseif type(newState) == "boolean" then
            target = newState
        else
            target = not self._Toggled
        end
        self:SetToggleState(target)
        local theme = "Smooth"
        local soundKey = theme .. (self._Toggled and "On" or "Off")
        local soundAsset = self.ParentUI:GetSound(soundKey)
        if soundAsset then
            local s = Instance.new("Sound")
            s.SoundId = soundAsset
            s.Volume = 1
            s.Parent = SoundService
            s:Play()
            s.Ended:Connect(function() s:Destroy() end)
        end
        task.delay(0.1, function() self._Debounce = false end)
    end

    DynamicUI:UpdateModuleVisualState(module)

    moduleBtn.MouseButton1Click:Connect(function()
        module:Toggle()
    end)

    moduleBtn.MouseButton2Click:Connect(function()
        module._SettingsOpen = not module._SettingsOpen
        local contentHeight = layout.AbsoluteContentSize.Y + 10
        local targetHeight = math.min(contentHeight, 200)
        local h = module._SettingsOpen and targetHeight or 0
        TweenService:Create(moduleSettings, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(1,0,0,h)}):Play()
        TweenService:Create(moduleFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(1,0,0,30 + h)}):Play()
    end)

    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        if module._SettingsOpen then
            local ch = layout.AbsoluteContentSize.Y + 10
            local h  = math.min(ch, 200)
            moduleSettings.Size = UDim2.new(1,0,0,h)
            moduleFrame.Size    = UDim2.new(1,0,0,30 + h)
        end
    end)

    if module.Keybind ~= Enum.KeyCode.Unknown then
        UserInputService.InputBegan:Connect(function(input, gpe)
            if not gpe and input.UserInputType == Enum.UserInputType.Keyboard
               and input.KeyCode == module.Keybind then
                module:Toggle()
            end
        end)
    end

    table.insert(tab.Modules, module)
    self._flagControls[actualFlag] = module

    local visibleFlag = module.Name .. "_Visible"
    if self.Flags[visibleFlag] == nil then
        self.Flags[visibleFlag] = true
    end
    local visibleToggle = self:AddToggle(module, "Visible", self.Flags[visibleFlag], function(state)
        self.Flags[visibleFlag] = state
        if self.RefreshArraylist then
            pcall(function() self:RefreshArraylist() end)
        end
    end, nil)

    module.Frame.Visible = true

    return module
end


---------------------------------------------------------------------
-- ELEMENTS
---------------------------------------------------------------------

-- Corrected AddToggle (uses self.Images and proper anchoring)
function DynamicUI:AddToggle(module, elementName, defaultValue, callback, condition, flagName)
    -- flagName defaults to elementName if not supplied
    flagName = flagName or elementName

    -- if a value already exists in Flags, use it; otherwise use defaultValue
    local initialValue
    if self.Flags[flagName] ~= nil then
        initialValue = self.Flags[flagName]
    else
        initialValue = (defaultValue ~= nil) and defaultValue or false
        -- make sure the flag table is populated so SaveConfig will catch it
        self.Flags[flagName] = initialValue
    end

    local toggleFrame = Instance.new("Frame")
    toggleFrame.Name = elementName .. "_Toggle"
    toggleFrame.Size = UDim2.new(1, 0, 0, 25)
    toggleFrame.BackgroundTransparency = 1
    toggleFrame.Parent = module.Settings

    -- Label
    local label = Instance.new("TextLabel")
    label.Name = "ToggleLabel"
    label.Text = elementName
    label.FontFace = Font.new("rbxassetid://12187365559")
    label.TextSize = 24
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(0.8, 0, 1, 0)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = toggleFrame

    local labelPadding = Instance.new("UIPadding", label)
    labelPadding.PaddingLeft = UDim.new(0, 5)
    labelPadding.PaddingBottom = UDim.new(0, 5)

    -- Text lift effect
    self:CreateTextLift(label, {
        OffsetX = 1.2,
        OffsetY = 1,
        Color = Color3.fromRGB(145,145,145),
        Transparency = 0.5
    })

    -- Toggle image
    local toggledImage = Instance.new("ImageButton")
    toggledImage.Name = "ToggledImage"
    toggledImage.Size = UDim2.new(0, 20, 0, 20)
    toggledImage.AnchorPoint = Vector2.new(1, 0.5)
    toggledImage.Position = UDim2.new(1, -8, 0.4, 0)
    toggledImage.BackgroundTransparency = 1
    toggledImage.BorderSizePixel = 0
    toggledImage.Image = self.Images["ToggledImage"]
    toggledImage.ImageTransparency = 1
    toggledImage.Parent = toggleFrame

    local gradient = Instance.new("UIGradient")
    gradient.Name = "RainbowGradient"
    gradient.Parent = toggledImage
    gradient.Enabled = false

    local toggleData = {
        Frame = toggleFrame,
        Image = toggledImage,
        Gradient = gradient,
        Toggled = initialValue,
        Callback = callback,
        Condition = condition,
        -- SetValue allows LoadConfig to apply a saved flag
        SetValue = function(_, state) setState(state) end
    }

    -- Toggle logic
    local function setState(state)
        toggleData.Toggled = state
        -- keep Flags table in sync
        self.Flags[flagName] = state

        if state then
            gradient.Enabled = true
            TweenService:Create(
                toggledImage,
                TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                { ImageTransparency = 0 }
            ):Play()
        else
            local tween = TweenService:Create(
                toggledImage,
                TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                { ImageTransparency = 1 }
            )
            tween:Play()
            tween.Completed:Connect(function()
                if not toggleData.Toggled then
                    gradient.Enabled = false
                end
            end)
        end

        if callback then
            pcall(callback, toggleData.Toggled)
        end
    end

    -- expose setState so LoadConfig can call it
    toggleData.SetValue = function(_, v) setState(v) end

    -- initial state
    setState(initialValue)

    -- allow clicking label or image
    toggledImage.MouseButton1Click:Connect(function() setState(not toggleData.Toggled) end)
    label.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            setState(not toggleData.Toggled)
        end
    end)

    -- Visibility helper
    function toggleData:RefreshVisibility()
        if not condition then
            toggleFrame.Visible = true
        else
            local ok, show = pcall(condition)
            toggleFrame.Visible = (ok and show) or false
        end
    end
    toggleData:RefreshVisibility()

    -- Register in module and flag controls for config save/load
    table.insert(module.Elements, toggleData)
    self._flagControls[flagName] = toggleData
    return toggleData
end

function DynamicUI:AddSlider(
    module,
    elementName,
    minValue,
    maxValue,
    defaultValue,
    callback,
    condition,
    rounding,
    flagName -- optional flag identifier
)
    -- optional flagName defaults to elementName
    flagName = flagName or elementName

    ----------------------------------------------------------------
    -- ROUNDING / STEP
    ----------------------------------------------------------------
    rounding = math.max(0, tonumber(rounding) or 0)
    local step
    if rounding == 0 then
        step = 1
    elseif rounding == 1 then
        step = 0.1
    else
        step = 10 ^ (-rounding)
    end
    local displayDecimals = (rounding <= 2) and 2 or rounding
    local formatStr = "%." .. tostring(displayDecimals) .. "f"

    ----------------------------------------------------------------
    -- INITIAL VALUE (respect Flags)
    ----------------------------------------------------------------
    local initialValue
    if self.Flags[flagName] ~= nil then
        initialValue = tonumber(self.Flags[flagName]) or defaultValue
    else
        initialValue = defaultValue
        self.Flags[flagName] = initialValue
    end

    ----------------------------------------------------------------
    -- UI CONTAINER
    ----------------------------------------------------------------
    local sliderFrame = Instance.new("Frame")
    sliderFrame.Name = elementName .. "_Slider"
    sliderFrame.Size = UDim2.new(1, 0, 0, 25)
    sliderFrame.BackgroundTransparency = 1
    sliderFrame.Parent = module.Settings

    ----------------------------------------------------------------
    -- MAIN LABEL
    ----------------------------------------------------------------
    local label = Instance.new("TextLabel")
    label.Name = "SliderLabel"
    label.Text = elementName
    label.FontFace = Font.new("rbxassetid://12187365559")
    label.TextSize = 24
    label.TextColor3 = Color3.fromRGB(255,255,255)
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(0.5, 0, 1, 0)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ZIndex = 2
    label.Parent = sliderFrame

    local labelPadding = Instance.new("UIPadding", label)
    labelPadding.PaddingLeft = UDim.new(0,5)
    labelPadding.PaddingBottom = UDim.new(0,5)
    self:CreateTextLift(label,{OffsetX=1.2,OffsetY=1,Color=Color3.fromRGB(145,145,145),Transparency=0.5})

    ----------------------------------------------------------------
    -- VALUE LABEL
    ----------------------------------------------------------------
    local valueLabel = Instance.new("TextLabel")
    valueLabel.Name = "SliderValue"
    valueLabel.Text = string.format(formatStr, initialValue)
    valueLabel.FontFace = Font.new("rbxassetid://12187365559")
    valueLabel.TextSize = 24
    valueLabel.TextColor3 = Color3.fromRGB(145,145,145)
    valueLabel.BackgroundTransparency = 1
    valueLabel.Size = UDim2.new(0.5,-5,1,0)
    valueLabel.Position = UDim2.new(0.5,0,0,0)
    valueLabel.TextXAlignment = Enum.TextXAlignment.Right
    valueLabel.ZIndex = 2
    valueLabel.Parent = sliderFrame

    local valuePadding = Instance.new("UIPadding", valueLabel)
    valuePadding.PaddingRight = UDim.new(0,5)
    valuePadding.PaddingBottom = UDim.new(0,5)
    self:CreateTextLift(valueLabel,{OffsetX=1.2,OffsetY=1,Color=Color3.fromRGB(0,0,0),Transparency=0})

    ----------------------------------------------------------------
    -- SLIDER BAR + FILL
    ----------------------------------------------------------------
    local sliderBar = Instance.new("Frame")
    sliderBar.Name = "SliderBar"
    sliderBar.Size = UDim2.new(1,-25,0,2)
    sliderBar.Position = UDim2.new(0,8,0.8,0)
    sliderBar.BackgroundColor3 = Color3.fromRGB(100,100,100)
    sliderBar.BackgroundTransparency = 1
    sliderBar.BorderSizePixel = 0
    sliderBar.ZIndex = 0
    sliderBar.Parent = sliderFrame
    Instance.new("UICorner", sliderBar).CornerRadius = UDim.new(0,8)

    local fill = Instance.new("Frame")
    fill.Name = "Fill"
    fill.Size = UDim2.new((initialValue-minValue)/(maxValue-minValue),0,1,0)
    fill.BackgroundColor3 = Color3.fromRGB(255,255,255)
    fill.BorderSizePixel = 0
    fill.ZIndex = 0
    fill.Parent = sliderBar
    Instance.new("UICorner", fill).CornerRadius = UDim.new(0,4)
    local gradient = Instance.new("UIGradient", fill)

    local circle = Instance.new("ImageButton")
    circle.Name = "Handle"
    circle.Size = UDim2.new(0,12,0,12)
    circle.BackgroundTransparency = 1
    circle.AnchorPoint = Vector2.new(0.5,0.5)
    circle.Position = UDim2.new(fill.Size.X.Scale,0,0.5,0)
    circle.ZIndex = 0
    circle.Image = self.Images["CircleImage"]
    circle.Parent = sliderBar
    local modifiedGradient = Instance.new("UIGradient", circle)

    ----------------------------------------------------------------
    -- SLIDER DATA & LOGIC
    ----------------------------------------------------------------
    local sliderData = {
        Frame = sliderFrame,
        Value = initialValue,
        Min = minValue,
        Max = maxValue,
        Step = step,
        Gradient = gradient,
        ModifiedGradient = modifiedGradient,
        IsSlider = true,
        Callback = callback,
        Condition = condition,
        Rounding = rounding,
    }

    local lastValue
    local function setValue(val)
        val = math.clamp(val, minValue, maxValue)
        val = math.floor((val / step) + 0.5) * step
        if lastValue and math.abs(val - lastValue) < 1e-6 then return end
        sliderData.Value = val
        lastValue = val
        local pct = (val - minValue) / (maxValue - minValue)
        fill.Size = UDim2.new(pct, 0, 1, 0)
        circle.Position = UDim2.new(pct, 0, 0.5, 0)
        valueLabel.Text = string.format(formatStr, val)
        self.Flags[flagName] = val  -- keep Flags in sync
        if callback then pcall(callback, val) end
    end

    -- expose to config loader
    sliderData.SetValue = function(_, v) setValue(v) end

    -- Dragging
    local dragging = false
    circle.InputBegan:Connect(function(i)
        if i.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true end
    end)
    UserInputService.InputEnded:Connect(function(i)
        if i.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    UserInputService.InputChanged:Connect(function(i)
        if dragging and i.UserInputType == Enum.UserInputType.MouseMovement then
            local pos, size = sliderBar.AbsolutePosition, sliderBar.AbsoluteSize
            local pct = math.clamp((i.Position.X - pos.X) / size.X, 0, 1)
            setValue(minValue + pct * (maxValue - minValue))
        end
    end)

    setValue(initialValue)

    -- Visibility helper
    function sliderData:RefreshVisibility()
        if not condition then
            sliderFrame.Visible = true
        else
            local ok, show = pcall(condition)
            sliderFrame.Visible = (ok and show) or false
        end
    end
    sliderData:RefreshVisibility()

    table.insert(module.Elements, sliderData)
    self._flagControls[flagName] = sliderData
    return sliderData
end

function DynamicUI:AddColorKey(module, elementName, defaultColor, callback)
    module.Settings = module.Settings or Instance.new("Frame")
    module.Elements = module.Elements or {}
    local function rgbToHsv(c)
        local r,g,b=c.R,c.G,c.B
        local max,min=math.max(r,g,b),math.min(r,g,b)
        local h,s,v=0,0,max
        local d=max-min
        if max>0 then s=d/max end
        if d>0 then
            if max==r then h=((g-b)/d)%6
            elseif max==g then h=((b-r)/d)+2
            else h=((r-g)/d)+4 end
            h=h/6
        end
        return h,s,v
    end
    local function hsvToRgb(h,s,v)
        local i=math.floor(h*6)
        local f=h*6-i
        local p=v*(1-s)
        local q=v*(1-f*s)
        local t=v*(1-(1-f)*s)
        local r,g,b
        if i%6==0 then r,g,b=v,t,p
        elseif i==1 then r,g,b=q,v,p
        elseif i==2 then r,g,b=p,v,t
        elseif i==3 then r,g,b=p,q,v
        elseif i==4 then r,g,b=t,p,v
        else r,g,b=v,p,q end
        return Color3.new(r,g,b)
    end
    defaultColor=defaultColor or Color3.new(1,1,1)
    local h,s,v=rgbToHsv(defaultColor)
    local currentColor=defaultColor
    local row=Instance.new("Frame")
    row.Name=elementName.."_ColorToggle"
    row.Size=UDim2.new(1,0,0,25)
    row.BackgroundTransparency=1
    row.Parent=module.Settings
    local label=Instance.new("TextLabel")
    label.Size=UDim2.new(0.8,0,1,0)
    label.BackgroundTransparency=1
    label.Text=elementName
    label.FontFace = Font.new("rbxassetid://12187365559")
    label.TextSize = 24
    label.TextColor3=Color3.new(1,1,1)
    label.Size = UDim2.new(0.8, 0, 1, 0)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent=row
    local labelPadding = Instance.new("UIPadding", label)
    labelPadding.PaddingLeft = UDim.new(0,5)
    labelPadding.PaddingBottom = UDim.new(0,5)
    local swatch=Instance.new("ImageButton")
    swatch.Size=UDim2.new(0,22,0,22)
    swatch.AnchorPoint=Vector2.new(1,0.5)
    swatch.Position=UDim2.new(1,-8,0.5,0)
    swatch.BackgroundColor3=currentColor
    swatch.AutoButtonColor=false
    swatch.BorderSizePixel=0
    swatch.Parent=row
    local popupGui
    local POPUP_W,POPUP_H=190,150
    local WHEEL_SZ,WHEEL_PADDING=110,8
    local function clampScreenPos(x,y,w,h)
        local cam=workspace.CurrentCamera.ViewportSize
        return math.clamp(x,8,cam.X-w-8),math.clamp(y,8,cam.Y-h-8)
    end
    local closeConn
    local function cleanupPopup()
        if closeConn then
            closeConn:Disconnect()
            closeConn=nil
        end
        if popupGui then
            popupGui:Destroy()
            popupGui=nil
        end
    end
    local function createPopup()
        cleanupPopup()
        popupGui=Instance.new("ScreenGui")
        popupGui.IgnoreGuiInset=true
        popupGui.ResetOnSpawn=false
        popupGui.ZIndexBehavior=Enum.ZIndexBehavior.Sibling
        popupGui.Parent=PlayerGui
        local frame=Instance.new("Frame")
        frame.Size=UDim2.new(0,POPUP_W,0,POPUP_H)
        local sp,ss=swatch.AbsolutePosition,swatch.AbsoluteSize
        local px,py=clampScreenPos(sp.X+ss.X+8,sp.Y+ss.Y*0.5-POPUP_H*0.5,POPUP_W,POPUP_H)
        frame.Position=UDim2.new(0,px,0,py)
        frame.BackgroundColor3=Color3.fromRGB(28,28,28)
        frame.BorderSizePixel=0
        frame.Parent=popupGui
        Instance.new("UICorner",frame).CornerRadius=UDim.new(0,8)
        Instance.new("UIStroke",frame).Color=Color3.fromRGB(70,70,70)
        frame.BackgroundTransparency=1
        frame.Size=UDim2.new(0,POPUP_W*0.8,0,POPUP_H*0.8)
        frame.Position=UDim2.new(0,px,0,py+10)
        TweenService:Create(frame,TweenInfo.new(0.25,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{BackgroundTransparency=0,Size=UDim2.new(0,POPUP_W,0,POPUP_H),Position=UDim2.new(0,px,0,py)}):Play()
        local wheel=Instance.new("ImageButton")
        wheel.Size=UDim2.new(0,WHEEL_SZ,0,WHEEL_SZ)
        wheel.Position=UDim2.new(0,WHEEL_PADDING,0,WHEEL_PADDING)
        wheel.BackgroundTransparency=1
        wheel.Image=self.Images and self.Images["ColorWheel"] or ""
        wheel.Parent=frame
        local cursor=Instance.new("Frame")
        cursor.Size=UDim2.new(0,10,0,10)
        cursor.AnchorPoint=Vector2.new(0.5,0.5)
        cursor.BackgroundTransparency=1
        cursor.Parent=wheel
        Instance.new("UICorner",cursor).CornerRadius=UDim.new(1,0)
        local cStroke=Instance.new("UIStroke",cursor)
        cStroke.Color=Color3.new(1,1,1)
        cStroke.Thickness=2
        local cShadow=Instance.new("UIStroke",cursor)
        cShadow.Color=Color3.new(0,0,0)
        cShadow.Thickness=4
        cShadow.Transparency=0.65
        local sliderBg=Instance.new("Frame")
        sliderBg.Size=UDim2.new(0,WHEEL_SZ,0,16)
        sliderBg.Position=UDim2.new(0,WHEEL_PADDING,0,WHEEL_PADDING+WHEEL_SZ+8)
        sliderBg.BackgroundColor3=Color3.fromRGB(220,220,220)
        sliderBg.BorderSizePixel=0
        sliderBg.Parent=frame
        local grad=Instance.new("UIGradient",sliderBg)
        grad.Color=ColorSequence.new{ColorSequenceKeypoint.new(0,Color3.new(0,0,0)),ColorSequenceKeypoint.new(1,Color3.new(1,1,1))}
        local knobContainer=Instance.new("Frame")
        knobContainer.Size=UDim2.new(0,20,0,20)
        knobContainer.AnchorPoint=Vector2.new(0.5,0.5)
        knobContainer.BackgroundTransparency=1
        knobContainer.Parent=sliderBg
        local arrowUp=Instance.new("ImageLabel")
        arrowUp.BackgroundTransparency=1
        arrowUp.Size=UDim2.new(0,20,0,15)
        arrowUp.Position=UDim2.new(0,0,0.25,0)
        arrowUp.Image=self.Images and self.Images["ArrowUp"] or ""
        arrowUp.Parent=knobContainer
        local arrowDown=Instance.new("ImageLabel")
        arrowDown.BackgroundTransparency=1
        arrowDown.Size=UDim2.new(0,20,0,15)
        arrowDown.Image=self.Images and self.Images["ArrowDown"] or ""
        arrowDown.Parent=knobContainer
        local rgbContainer=Instance.new("Frame")
        rgbContainer.Size=UDim2.new(0,50,0,WHEEL_SZ)
        rgbContainer.Position=UDim2.new(0,WHEEL_PADDING+WHEEL_SZ+8,0,WHEEL_PADDING)
        rgbContainer.BackgroundTransparency=1
        rgbContainer.Parent=frame
        local boxes,labels={},{"R","G","B"}
        for i,name in ipairs(labels) do
            local holder=Instance.new("Frame")
            holder.Size=UDim2.new(1,0,0,(WHEEL_SZ/3)-4)
            holder.Position=UDim2.new(0,0,0,(i-1)*(WHEEL_SZ/3))
            holder.BackgroundTransparency=1
            holder.Parent=rgbContainer
            local lab=Instance.new("TextLabel")
            lab.Size=UDim2.new(0.4,0,1,0)
            lab.BackgroundTransparency=1
            lab.Text=name
            lab.TextColor3=Color3.new(1,1,1)
            lab.FontFace=Font.new("rbxassetid://12187365559", Enum.FontWeight.Bold)
            lab.TextSize=16
            lab.Parent=holder
            local box=Instance.new("TextBox")
            box.Size=UDim2.new(0.6,0,1,0)
            box.Position=UDim2.new(0.4,0,0,0)
            box.BackgroundColor3=Color3.fromRGB(50,50,50)
            box.BorderSizePixel=0
            box.TextColor3=Color3.new(1,1,1)
            box.FontFace=Font.new("rbxassetid://12187365559")
            box.TextSize=14
            box.ClearTextOnFocus=false
            box.Text=tostring(math.floor(currentColor[name]*255+0.5))
            box.Parent=holder
            Instance.new("UICorner",box).CornerRadius=UDim.new(0,4)
            boxes[name]=box
            box:GetPropertyChangedSignal("Text"):Connect(function()
                local filtered=box.Text:gsub("%D","")
                if filtered~=box.Text then box.Text=filtered end
            end)
        end
        local hexBox=Instance.new("TextBox")
        hexBox.Size=UDim2.new(0.3,0,0,24)
        hexBox.Position=UDim2.new(0.67,0,0,WHEEL_PADDING+WHEEL_SZ)
        hexBox.BackgroundColor3=Color3.fromRGB(50,50,50)
        hexBox.BorderSizePixel=0
        hexBox.TextColor3=Color3.new(1,1,1)
        hexBox.FontFace=Font.new("rbxassetid://12187365559")
        hexBox.TextSize=14
        hexBox.ClearTextOnFocus=false
        hexBox.PlaceholderText="#RRGGBB"
        hexBox.Text = string.format("#%02X%02X%02X",math.floor(currentColor.R*255),math.floor(currentColor.G*255),math.floor(currentColor.B*255))
        hexBox.Parent=frame
        Instance.new("UICorner",hexBox).CornerRadius=UDim.new(0,4)
        local draggingWheel,draggingSlider=false,false
        local function refreshUI(fromBoxes,fromHex)
            currentColor=hsvToRgb(h,s,v)
            swatch.BackgroundColor3=currentColor
            local r=wheel.AbsoluteSize.X*0.5
            local angle=h*2*math.pi
            local dist=s*r
            cursor.Position=UDim2.new(0,r+math.cos(angle)*dist,0,r-math.sin(angle)*dist)
            knobContainer.Position=UDim2.new(v,0,0.5,0)
            if not fromBoxes then
                boxes.R.Text=tostring(math.floor(currentColor.R*255+0.5))
                boxes.G.Text=tostring(math.floor(currentColor.G*255+0.5))
                boxes.B.Text=tostring(math.floor(currentColor.B*255+0.5))
            end
            if not fromHex then
                hexBox.Text=string.format("#%02X%02X%02X",math.floor(currentColor.R*255),math.floor(currentColor.G*255),math.floor(currentColor.B*255))
            end
            if callback then callback(currentColor) end
        end
        task.defer(refreshUI)
        wheel.InputBegan:Connect(function(i)
            if i.UserInputType==Enum.UserInputType.MouseButton1 then
                draggingWheel=true
                TweenService:Create(cursor,TweenInfo.new(0.1),{Size=UDim2.new(0,15,0,15)}):Play()
            end
        end)
        sliderBg.InputBegan:Connect(function(i)
            if i.UserInputType==Enum.UserInputType.MouseButton1 then draggingSlider=true end
        end)
        UserInputService.InputEnded:Connect(function(i)
            if i.UserInputType==Enum.UserInputType.MouseButton1 then
                if draggingWheel then
                    TweenService:Create(cursor,TweenInfo.new(0.1),{Size=UDim2.new(0,10,0,10)}):Play()
                end
                draggingWheel=false
                draggingSlider=false
            end
        end)
        UserInputService.InputChanged:Connect(function(i)
            if i.UserInputType~=Enum.UserInputType.MouseMovement then return end
            if draggingWheel then
                local center=wheel.AbsolutePosition+wheel.AbsoluteSize*0.5
                local rel=Vector2.new(i.Position.X-center.X,center.Y-i.Position.Y)
                h=(math.atan2(rel.Y,rel.X)/(2*math.pi))%1
                s=math.clamp(rel.Magnitude/(wheel.AbsoluteSize.X*0.5),0,1)
                refreshUI()
            elseif draggingSlider then
                v=math.clamp((i.Position.X-sliderBg.AbsolutePosition.X)/sliderBg.AbsoluteSize.X,0,1)
                refreshUI()
            end
        end)
        for comp,box in pairs(boxes) do
            box.FocusLost:Connect(function()
                local n=tonumber(box.Text)
                if n then
                    n=math.clamp(n,0,255)
                    box.Text=tostring(n)
                    local col=Color3.fromRGB(tonumber(boxes.R.Text) or 0,tonumber(boxes.G.Text) or 0,tonumber(boxes.B.Text) or 0)
                    h,s,v=rgbToHsv(col)
                    refreshUI(true)
                else
                    box.Text=tostring(math.floor(currentColor[comp]*255+0.5))
                end
            end)
        end
        hexBox.FocusLost:Connect(function()
            local text=hexBox.Text:gsub("#","")
            if #text==6 then
                local r=tonumber(text:sub(1,2),16)
                local g=tonumber(text:sub(3,4),16)
                local b=tonumber(text:sub(5,6),16)
                if r and g and b then
                    local col=Color3.fromRGB(r,g,b)
                    h,s,v=rgbToHsv(col)
                    refreshUI(false,true)
                else
                    hexBox.Text=string.format("#%02X%02X%02X",math.floor(currentColor.R*255),math.floor(currentColor.G*255),math.floor(currentColor.B*255))
                end
            else
                hexBox.Text=string.format("#%02X%02X%02X",math.floor(currentColor.R*255),math.floor(currentColor.G*255),math.floor(currentColor.B*255))
            end
        end)
        closeConn=UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType==Enum.UserInputType.MouseButton1 then
                local pos=input.Position
                local fPos,fSize=frame.AbsolutePosition,frame.AbsoluteSize
                local inside=pos.X>=fPos.X and pos.X<=fPos.X+fSize.X and pos.Y>=fPos.Y and pos.Y<=fPos.Y+fSize.Y
                if not inside then cleanupPopup() end
            end
        end)
    end
    swatch.MouseButton1Click:Connect(function()
        if popupGui then cleanupPopup() else createPopup() end
    end)
    local colorData={
        Frame=row,
        Button=swatch,
        GetColor=function() return currentColor end,
        SetColor=function(_,col)
            if typeof(col)=="Color3" then
                h,s,v=rgbToHsv(col)
                currentColor=col
                swatch.BackgroundColor3=col
                if popupGui then popupGui:Destroy() popupGui=nil createPopup() end
                if callback then callback(col) end
            end
        end
    }
    table.insert(module.Elements,colorData)
    return colorData
end

--[[--------------------------------------------------------------
DynamicUI:AddDropdown
Creates a dropdown UI element with:
 â€¢ left-click to cycle through options
 â€¢ right-click to expand/collapse full list
 â€¢ highlight + gradient tracking
----------------------------------------------------------------]]

function DynamicUI:AddDropdown(module, elementName, options, defaultValue, callback, flagName)
    ----------------------------------------------------------------
    -- guaranteed state
    ----------------------------------------------------------------
    self._flagControls = self._flagControls or {}
    self.Flags         = self.Flags or {}

    -- always store a valid key (string)
    flagName = tostring(flagName or elementName or "Dropdown")

    ----------------------------------------------------------------
    -- starting value
    ----------------------------------------------------------------
    options = table.clone(options or {})
    if #options == 0 then return nil end

    local initial
    if self.Flags[flagName] ~= nil then
        initial = tostring(self.Flags[flagName])
    else
        initial = defaultValue and tostring(defaultValue) or tostring(options[1])
        self.Flags[flagName] = initial
    end

    local currentIndex = table.find(options, initial) or 1
    local currentValue = options[currentIndex]
    self.Flags[flagName] = currentValue

    ----------------------------------------------------------------
    -- container
    ----------------------------------------------------------------
    local container = Instance.new("Frame")
    container.Name = elementName .. "_Dropdown"
    container.Size = UDim2.new(1, 0, 0, 30)
    container.BackgroundTransparency = 1
    container.Parent = module.Settings

    ----------------------------------------------------------------
    -- header
    ----------------------------------------------------------------
    local header = Instance.new("Frame")
    header.Size = UDim2.new(1, 0, 0, 30)
    header.BackgroundTransparency = 1
    header.Parent = container

    local rowBtn = Instance.new("TextButton")
    rowBtn.Size = UDim2.new(1, 0, 1, 0)
    rowBtn.Text = ""
    rowBtn.BackgroundTransparency = 1
    rowBtn.BorderSizePixel = 0
    rowBtn.AutoButtonColor = false
    rowBtn.ZIndex = 99
    rowBtn.Parent = header

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.8, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = elementName
    label.FontFace = Font.new("rbxassetid://12187365559")
    label.TextSize = 24
    label.TextColor3 = Color3.new(1,1,1)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = header
    local pad = Instance.new("UIPadding")
    pad.PaddingLeft = UDim.new(0, 5)
    pad.Parent = label
    self:CreateTextLift(label,{Offset=Vector2.new(1.2,1),Color=Color3.new(0.57,0.57,0.57),Transparency=0.5})

    local indicator = Instance.new("TextLabel")
    indicator.Name = "Value"
    indicator.Size = UDim2.new(0.5,-10,1,0)
    indicator.Position = UDim2.new(0.5,0,0,0)
    indicator.BackgroundTransparency = 1
    indicator.FontFace = Font.new("rbxassetid://12187365559")
    indicator.TextSize = 24
    indicator.TextColor3 = Color3.fromRGB(145,145,145)
    indicator.TextXAlignment = Enum.TextXAlignment.Right
    indicator.Text = currentValue
    indicator.Parent = header
    self:CreateTextLift(indicator,{OffsetX=1.2,OffsetY=1,Color=Color3.new(0,0,0),Transparency=0})

    ----------------------------------------------------------------
    -- list
    ----------------------------------------------------------------
    local listFrame = Instance.new("ScrollingFrame")
    listFrame.Name = "List"
    listFrame.Size = UDim2.new(1, 0, 0, 0)
    listFrame.Position = UDim2.new(0, 0, 0, 30)
    listFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    listFrame.BorderSizePixel = 0
    listFrame.ClipsDescendants = true
    listFrame.ScrollBarThickness = 0
    listFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
    listFrame.CanvasSize = UDim2.new()
    listFrame.Parent = container
    self:CreateDropShadow(listFrame)

    local layout = Instance.new("UIListLayout")
    layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Parent = listFrame

    ----------------------------------------------------------------
    -- dropdown object
    ----------------------------------------------------------------
    local dropdown = {
        Frame      = container,
        Button     = rowBtn,
        Gradients  = {},
        Gradient   = nil,
        IsDropdown = true,
    }

    local optionButtons = {}

    function dropdown:GetValue()
        return currentValue
    end

    function dropdown:SetValue(_, val)
        if not val then return end
        self.Flags = self.Flags or {}                   -- always safe
        local key = tostring(flagName)
        local i = table.find(options, val)
        if i then
            currentIndex = i
            currentValue = val
            self.Flags[key] = val
            indicator.Text = val
            if callback then callback(val) end
            dropdown:UpdateHighlight()
        end
    end

    function dropdown:UpdateHighlight()
        for i, btn in ipairs(optionButtons) do
            btn.Highlight.Visible = (i == currentIndex)
        end
    end

    ----------------------------------------------------------------
    -- option creation
    ----------------------------------------------------------------
    local function createOption(opt, i)
        local optBtn = Instance.new("TextButton")
        optBtn.Name = opt
        optBtn.Size = UDim2.new(1, 0, 0, 30)
        optBtn.BackgroundColor3 = Color3.fromRGB(28, 28, 28)
        optBtn.BorderSizePixel = 0
        optBtn.AutoButtonColor = false
        optBtn.Text = ""
        optBtn.Parent = listFrame

        local bar = Instance.new("Frame")
        bar.Name = "Highlight"
        bar.Size = UDim2.new(0, 2, 1, 0)
        bar.BorderSizePixel = 0
        bar.Visible = (i == currentIndex)
        bar.BackgroundColor3 = Color3.new(1,1,1)
        bar.Parent = optBtn

        local gradient = Instance.new("UIGradient")
        gradient.Parent = bar
        dropdown.Gradients["Gradient"..i] = gradient
        if i == 1 then dropdown.Gradient = gradient end

        local txt = Instance.new("TextLabel")
        txt.Size = UDim2.new(1, 0, 1, 0)
        txt.Position = UDim2.new(0, 6, 0, 0)
        txt.BackgroundTransparency = 1
        txt.Text = opt
        txt.FontFace = Font.new("rbxassetid://12187365559")
        txt.TextSize = 22
        txt.TextColor3 = Color3.fromRGB(145,145,145)
        txt.TextXAlignment = Enum.TextXAlignment.Left
        txt.Parent = optBtn
        self:CreateTextLift(txt,{OffsetX=1.2,OffsetY=1,Color=Color3.new(0,0,0),Transparency=0})

        optBtn.MouseButton1Click:Connect(function()
            self.Flags = self.Flags or {}
            local key = tostring(flagName)
            currentIndex = i
            currentValue = opt
            self.Flags[key] = opt
            indicator.Text = opt
            if callback then callback(opt) end
            dropdown:UpdateHighlight()
        end)

        table.insert(optionButtons, optBtn)
    end

    for i, opt in ipairs(options) do
        createOption(opt, i)
    end

    ----------------------------------------------------------------
    -- expand / collapse
    ----------------------------------------------------------------
    local isOpen = false
    local function resizeList(open)
        local h = open and math.min(layout.AbsoluteContentSize.Y, 200) or 0
        TweenService:Create(listFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(1, 0, 0, h)}):Play()
        TweenService:Create(container, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(1, 0, 0, 30 + h)}):Play()
    end

    local function toggleList(force)
        isOpen = (force ~= nil) and force or not isOpen
        resizeList(isOpen)
    end

    rowBtn.MouseButton1Click:Connect(function()
        if isOpen then
            toggleList(false)
        else
            currentIndex = (currentIndex % #options) + 1
            currentValue = options[currentIndex]
            self.Flags = self.Flags or {}
            self.Flags[flagName] = currentValue
            indicator.Text = currentValue
            if callback then callback(currentValue) end
            dropdown:UpdateHighlight()
        end
    end)

    rowBtn.MouseButton2Click:Connect(toggleList)

    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        if isOpen then resizeList(true) end
    end)

    ----------------------------------------------------------------
    -- refresh
    ----------------------------------------------------------------
    function dropdown:Refresh(newOptions, newDefault)
        self.Flags = self.Flags or {}
        for _, btn in ipairs(optionButtons) do btn:Destroy() end
        table.clear(optionButtons)
        table.clear(self.Gradients)
        self.Gradient  = nil

        options = table.clone(newOptions or options)
        if #options == 0 then
            currentIndex = 0
            currentValue = ""
            self.Flags[flagName] = ""
            indicator.Text = ""
            return
        end

        currentIndex = table.find(options, newDefault) or 1
        currentValue = options[currentIndex]
        self.Flags[flagName] = currentValue
        indicator.Text = currentValue

        for i, opt in ipairs(options) do createOption(opt, i) end

        task.defer(function()
            dropdown:UpdateHighlight()
            if isOpen then resizeList(true) end
        end)
    end

    ----------------------------------------------------------------
    -- register
    ----------------------------------------------------------------
    self._flagControls[flagName] = dropdown
    table.insert(module.Elements, dropdown)

    return dropdown
end


---------------------------------------------------------------------
--  AddInputBox
--  Creates a labeled TextBox that saves/loads a string flag.
---------------------------------------------------------------------
function DynamicUI:AddInputBox(module, elementName, defaultText, callback, condition, flagName)
    flagName = flagName or elementName
    self._flagControls = self._flagControls or {}
    self.Flags = self.Flags or {}

    -- determine initial text
    local initialText
    if self.Flags[flagName] ~= nil then
        initialText = tostring(self.Flags[flagName])
    else
        initialText = (defaultText ~= nil) and tostring(defaultText) or ""
        self.Flags[flagName] = initialText
    end

    assert(module and module.Settings, "AddInputBox requires a valid module with Settings")

    -- main container
    local inputFrame = Instance.new("Frame")
    inputFrame.Name = elementName .. "_InputBox"
    inputFrame.Size = UDim2.new(1, 0, 0, 25)
    inputFrame.BackgroundTransparency = 1
    inputFrame.Parent = module.Settings

    -- label
    local label = Instance.new("TextLabel")
    label.Name = "InputLabel"
    label.Text = elementName
    label.FontFace = Font.new("rbxassetid://12187365559")
    label.TextSize = 24
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(0.4, 0, 1, 0)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = inputFrame

    local labelPadding = Instance.new("UIPadding")
    labelPadding.PaddingLeft = UDim.new(0, 5)
    labelPadding.PaddingBottom = UDim.new(0, 5)
    labelPadding.Parent = label

    -- optional shadow
    if self.CreateTextLift then
        self:CreateTextLift(label, {
            OffsetX = 1.2,
            OffsetY = 1,
            Color = Color3.fromRGB(145,145,145),
            Transparency = 0.5
        })
    end

    -- input field
    local textBox = Instance.new("TextBox")
    textBox.Name = "InputField"
    textBox.Text = initialText
    textBox.ClearTextOnFocus = false
    textBox.FontFace = Font.new("rbxassetid://12187365559")
    textBox.TextSize = 22
    textBox.TextColor3 = Color3.fromRGB(145,145,145)
    textBox.BackgroundColor3 = Color3.fromRGB(30,30,30)
    textBox.BackgroundTransparency = 0.2
    textBox.BorderSizePixel = 0
    textBox.Size = UDim2.new(0.3, 0, 0.8, 0)
    textBox.Position = UDim2.new(0.65, 0, 0, 0)
    textBox.TextXAlignment = Enum.TextXAlignment.Center
    textBox.Parent = inputFrame

    -- text shadow
    if self.CreateTextLift then
        self:CreateTextLift(textBox, {
            OffsetX = 1.2,
            OffsetY = 1,
            Color = Color3.new(0,0,0),
            Transparency = 0
        })
    end

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0,4)
    corner.Parent = textBox

    --------------------------------------------------------------------
    --  Custom auto-resizing for FontFace using TextBounds
    --------------------------------------------------------------------
    local minSize = 10
    local defaultSize = textBox.TextSize

    -- hidden measurer
    local measurer = Instance.new("TextLabel")
    measurer.Visible = false
    measurer.BackgroundTransparency = 1
    measurer.FontFace = textBox.FontFace
    measurer.Parent = inputFrame

    local function resize()
        local boxWidth = textBox.AbsoluteSize.X
        local currentSize = defaultSize
        local t = textBox.Text
        while currentSize > minSize do
            measurer.TextSize = currentSize
            measurer.Text = t
            -- Wait one render step to update TextBounds
            measurer:GetPropertyChangedSignal("TextBounds"):Wait()
            if measurer.TextBounds.X <= boxWidth - 8 then
                break
            end
            currentSize -= 1
        end
        textBox.TextSize = currentSize
    end
    textBox:GetPropertyChangedSignal("Text"):Connect(resize)
    textBox:GetPropertyChangedSignal("AbsoluteSize"):Connect(resize)
    resize()

    --------------------------------------------------------------------
    -- commit helper
    --------------------------------------------------------------------
    local function commit(newText)
        newText = tostring(newText or "")
        self.Flags[flagName] = newText
        if callback then
            pcall(callback, newText)
        end
    end

    -- Only fire when Enter is pressed
    textBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            commit(textBox.Text)
        end
    end)

    --------------------------------------------------------------------
    -- return control object
    --------------------------------------------------------------------
    local inputData = {
        Frame = inputFrame,
        TextBox = textBox,
        Condition = condition,
        Callback = callback,
        SetValue = function(_, newText)
            newText = tostring(newText or "")
            textBox.Text = newText
            self.Flags[flagName] = newText
        end,
        RefreshVisibility = function()
            if not condition then
                inputFrame.Visible = true
            else
                local ok, show = pcall(condition)
                inputFrame.Visible = (ok and show) or false
            end
        end
    }

    inputData:RefreshVisibility()
    module.Elements = module.Elements or {}
    table.insert(module.Elements, inputData)
    self._flagControls[flagName] = inputData

    return inputData
end

---------------------------------------------------------------------
-- CUSTOM FUNCTIONS
---------------------------------------------------------------------

function DynamicUI:UpdateModuleVisualState(module)
    if not module then return end

    if module._Toggled then
        module.Text.TextColor3 = Color3.fromRGB(255,255,255)
        module.Button.BackgroundColor3 = Color3.fromRGB(40,40,40)
        if module._Gradient then
            module._Gradient.Transparency = NumberSequence.new(0)
        end
    else
        module.Text.TextColor3 = Color3.fromRGB(145,145,145)
        module.Button.BackgroundColor3 = Color3.fromRGB(28,28,28)
        if module._Gradient then
            module._Gradient.Transparency = NumberSequence.new(1)
        end
    end
end

function DynamicUI:ToggleUI(state)
    -- Toggle visibility or set explicitly
    self.Visible = (type(state) == "boolean") and state or not self.Visible

    -- Sync Click GUI module
    if self.ClickGUIModule then
        self.ClickGUIModule._Toggled = self.Visible
        self:UpdateModuleVisualState(self.ClickGUIModule)
    end

    -- Animation settings
    local anim, dur = self.Config.ToggleAnimation, self.Config.ToggleDuration or 0.3
    local style, direction = Enum.EasingStyle.Quad, Enum.EasingDirection.InOut

    for _, tab in ipairs(self.Tabs) do
        local holder = tab.Holder
        local targetPos = tab.SavedPosition or tab.OriginalPosition

        if self.Visible then
            if anim == "SlideLeft" then
                TweenService:Create(holder, TweenInfo.new(dur, style, direction), {
                    Position = targetPos
                }):Play()
            elseif anim == "SlideRight" then
                TweenService:Create(holder, TweenInfo.new(dur, style, direction), {
                    Position = targetPos
                }):Play()
            elseif anim == "SlideUp" then
                TweenService:Create(holder, TweenInfo.new(dur, style, direction), {
                    Position = targetPos
                }):Play()
            elseif anim == "SlideDown" then
                TweenService:Create(holder, TweenInfo.new(dur, style, direction), {
                    Position = targetPos
                }):Play()
            elseif anim == "Bounce" then
                TweenService:Create(holder, TweenInfo.new(dur, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Position = targetPos
                }):Play()
            end
        else
            -- Hiding animations
            if anim == "SlideLeft" then
                targetPos = UDim2.new(0, -holder.AbsoluteSize.X - 50, holder.Position.Y.Scale, holder.Position.Y.Offset)
            elseif anim == "SlideRight" then
                targetPos = UDim2.new(0, self.ScreenGui.AbsoluteSize.X + 50, holder.Position.Y.Scale, holder.Position.Y.Offset)
            elseif anim == "SlideUp" then
                targetPos = UDim2.new(holder.Position.X.Scale, holder.Position.X.Offset, 0, -holder.AbsoluteSize.Y - 500)
            elseif anim == "SlideDown" then
                targetPos = UDim2.new(holder.Position.X.Scale, holder.Position.X.Offset, 0, self.ScreenGui.AbsoluteSize.Y + 500)
            elseif anim == "Bounce" then
                -- Default hide: just fade/slide down slightly
                targetPos = UDim2.new(holder.Position.X.Scale, holder.Position.X.Offset, 0, self.ScreenGui.AbsoluteSize.Y + 500)
            end

            TweenService:Create(holder, TweenInfo.new(dur, style, direction), {
                Position = targetPos
            }):Play()
        end
    end
end

---------------------------------------------------------------------
-- DEMO & TOGGLE UI
---------------------------------------------------------------------

-- Keybind to toggle modules
return DynamicUI
